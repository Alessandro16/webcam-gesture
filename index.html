<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand AI Experience - Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Courier New', monospace; }
        #webcam { display: none; }
        canvas { position: fixed; top: 0; left: 0; pointer-events: none; }
        
        .ui-container {
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 100;
            transition: opacity 1s ease;
        }
        
        .card {
            background: rgba(20, 20, 20, 0.9);
            padding: 40px; border-radius: 20px;
            border: 1px solid #333;
        }

        button {
            padding: 15px 40px; background: #fff; border: none;
            border-radius: 30px; cursor: pointer; font-weight: bold;
            font-size: 1.2rem;
        }
        
        #gesture-label {
            position: fixed; bottom: 30px; left: 50%;
            transform: translateX(-50%); font-size: 1.5rem;
            text-transform: uppercase; letter-spacing: 5px; opacity: 0.7;
            color: white; pointer-events: none;
        }
    </style>
</head>
<body>

    <canvas id="particleCanvas"></canvas>
    <video id="webcam" autoplay playsinline></video>

    <div class="ui-container" id="ui">
        <div class="card">
            <h1>Dreamer AI</h1>
            <p id="status">Caricamento modelli...</p>
            <button id="start-btn" style="display: none;">INIZIA</button>
        </div>
    </div>

    <div id="gesture-label"></div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        const video = document.getElementById("webcam");
        const canvas = document.getElementById("particleCanvas");
        const ctx = canvas.getContext("2d");
        const ui = document.getElementById("ui");
        const startBtn = document.getElementById("start-btn");
        const label = document.getElementById("gesture-label");

        let handLandmarker;
        let particles = [];
        let currentGesture = 'none';
        let particleColor = 'white';

        // --- Generatori di Forme (Coordinate Centrate) ---
        
        function getHeartPoints(num) {
            const points = [];
            const scale = 15; // Dimensione del cuore
            for (let i = 0; i < num; i++) {
                const t = (i / num) * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                points.push({ x: x * scale + canvas.width/2, y: y * scale + canvas.height/2 });
            }
            return points;
        }

        function getSpherePoints(num) {
            const points = [];
            const radius = 100;
			
            for (let i = 0; i < num; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = radius * Math.sqrt(Math.random());
                points.push({
                    x: Math.cos(angle) * r + canvas.width/2,
                    y: Math.sin(angle) * r + canvas.height/2
                });
            }
            return points;
        }

        function getTextPoints(text) {
            const points = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.font = "bold 120px Arial";
            ctx.textAlign = "center";
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            for (let y = 0; y < canvas.height; y += 8) {
                for (let x = 0; x < canvas.width; x += 8) {
                    if (data[(y * canvas.width + x) * 4 + 3] > 128) {
                        points.push({ x, y });
                    }
                }
            }
            return points;
        }

        // --- MODIFICHE NEL SISTEMA PARTICELLE ---

		const PARTICLE_COUNT = 2000; // Molte pi√π particelle per un effetto denso
		const JITTER_AMOUNT = 25;    // Quanto devono essere "spettinate" le forme

		class Particle {
			constructor() {
				this.x = Math.random() * canvas.width;
				this.y = Math.random() * canvas.height;
				this.destX = this.x;
				this.destY = this.y;
				this.vx = 0;
				this.vy = 0;
				// Velocit√† diverse per ogni particella per un movimento pi√π organico
				this.accel = 0.02 + Math.random() * 0.04; 
				this.friction = 0.88 + Math.random() * 0.04;
				this.size = Math.random() * 1.5 + 0.5; // Particelle pi√π piccole e varie
			}

			update() {
				// Aggiungiamo un leggero tremolio costante (jitter)
				let jitterX = (Math.random() - 0.5) * JITTER_AMOUNT;
				let jitterY = (Math.random() - 0.5) * JITTER_AMOUNT;

				let dx = (this.destX + jitterX) - this.x;
				let dy = (this.destY + jitterY) - this.y;

				this.vx += dx * this.accel;
				this.vy += dy * this.accel;
				this.vx *= this.friction;
				this.vy *= this.friction;

				this.x += this.vx;
				this.y += this.vy;
			}

			draw() {
				// Usiamo un'opacit√† variabile per un effetto pi√π nebuloso
				ctx.fillStyle = particleColor;
				ctx.globalAlpha = 0.6; 
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
				ctx.fill();
				ctx.globalAlpha = 1.0;
			}
		}

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(new Particle());

        // --- Logica Gesti ---

        function setFormation(gesture) {
            currentGesture = gesture;
            let targetPoints = [];

            if (gesture === 'heart') {
                targetPoints = getHeartPoints(PARTICLE_COUNT);
                particleColor = '#ff3366';
                label.innerText = "‚ù§Ô∏è Heart Mode";
            } else if (gesture === 'love') {
                targetPoints = getTextPoints("I LOVE U");
                particleColor = '#33ccff';
                label.innerText = "‚ú® I LOVE U ‚ú®";
            } else if (gesture === 'sphere') {
                targetPoints = getSpherePoints(PARTICLE_COUNT);
                particleColor = '#ffcc00';
                label.innerText = "üåÄ Sphere Mode";
            } else {
                particleColor = 'white';
                label.innerText = "";
                particles.forEach(p => {
                    p.destX = p.x + (Math.random() - 0.5) * 50;
                    p.destY = p.y + (Math.random() - 0.5) * 50;
                });
                return;
            }

            particles.forEach((p, i) => {
                const target = targetPoints[i % targetPoints.length];
                p.destX = target.x;
                p.destY = target.y;
            });
        }

        // --- Loop Principale ---

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            document.getElementById("status").innerText = "Pronto.";
            startBtn.style.display = "inline-block";
        }
		
		//Cancello la card iniziale di aprtenza della webcam
        startBtn.onclick = () => {
            ui.style.opacity = "0";
            setTimeout(() => ui.style.display = "none", 1000);
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.onloadeddata = loop;
            });
        };

        function loop() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const results = handLandmarker.detectForVideo(video, performance.now());
            if (results.landmarks && results.landmarks.length > 0) {
                const pts = results.landmarks[0];
				
				//Var d contiene i valori di distanza delle varie parti della mano
                const d = (p1, p2) => Math.hypot(pts[p1].x - pts[p2].x, pts[p1].y - pts[p2].y);
                
				//Valori delle punte delle dita:
				//Pollice: 4
				//Indice: 8
				//Medio: 12
				//Anulare: 16
				//Mignolo: 20
				//Polso: 0
				
                // Riconoscimento Gesti
                const isHeart = d(4, 8) < 0.1;
                const isSphere = d(8, 0) < 0.25 && d(12, 0) < 0.40;
                const isOpen = d(8, 0) > 0.4 && d(12, 0) > 0.4;
				
				//Sistema a stati finiti, il processo ha sempre una forma da mostrare
				//Controllo se il gesto √® uguale al precedente in modo da evitare una visione a scatti nella forma
                if (isHeart && currentGesture !== 'heart') setFormation('heart');
                else if (isSphere && !isHeart && currentGesture !== 'sphere') setFormation('sphere');
                else if (isOpen && currentGesture !== 'love') setFormation('love');
                else if (!isHeart && !isSphere && !isOpen && currentGesture !== 'none') setFormation('none');

            } else if (currentGesture !== 'none') {
                setFormation('none');
            }

            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(loop);
        }

        initAI();
    </script>
</body>
</html>