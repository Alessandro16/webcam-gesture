<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hologram AI - Jupiter Zoom & Rotate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Courier New', monospace; }
        #webcam { display: none; }
        canvas { position: fixed; top: 0; left: 0; pointer-events: none; }
        
        .ui-container {
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 100;
            transition: opacity 1s ease;
        }
        
        .card {
            background: rgba(20, 20, 20, 0.9);
            padding: 40px; border-radius: 20px;
            border: 1px solid #333;
        }

        button {
            padding: 15px 40px; background: #fff; border: none;
            border-radius: 30px; cursor: pointer; font-weight: bold;
            font-size: 1.2rem;
        }
        
        #gesture-label {
            position: fixed; bottom: 30px; left: 50%;
            transform: translateX(-50%); font-size: 1.2rem;
            text-transform: uppercase; letter-spacing: 3px; opacity: 0.8;
            color: #ffcc00; pointer-events: none;
            background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 10px;
            white-space: nowrap;
        }
    </style>
</head>
<body>

    <canvas id="particleCanvas"></canvas>
    <video id="webcam" autoplay playsinline></video>

    <div class="ui-container" id="ui">
        <div class="card">
            <h1>Jupiter AI Engine</h1>
            <p id="status">Inizializzazione sensori...</p>
            <button id="start-btn" style="display: none;">AVVIA SISTEMA</button>
        </div>
    </div>

    <div id="gesture-label">CHIUDI IL PUGNO PER GENERARE</div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        const video = document.getElementById("webcam");
        const canvas = document.getElementById("particleCanvas");
        const ctx = canvas.getContext("2d");
        const ui = document.getElementById("ui");
        const startBtn = document.getElementById("start-btn");
        const label = document.getElementById("gesture-label");

        let handLandmarker;
        let particles = [];
        let currentGesture = 'none';
        let isLocked = false;
        let particleColor = 'white';
        let rotX = 0, rotY = 0;
        let zoomScale = 1.0;

        const PARTICLE_COUNT = 8000;
        const JITTER_AMOUNT = 10;

        function rotate3D(x, y, z, angleX, angleY) {
            let cosY = Math.cos(angleY), sinY = Math.sin(angleY);
            let x1 = x * cosY - z * sinY;
            let z1 = x * sinY + z * cosY;
            let cosX = Math.cos(angleX), sinX = Math.sin(angleX);
            let y2 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX;
            return { x: x1, y: y2, z: z2 };
        }

        function getJupiterPoints(num) {
            const points = [];
            const sphereCount = Math.floor(num * 0.4);
            const ringCount = num - sphereCount;
            const planetRadius = 80;

            for (let i = 0; i < sphereCount; i++) {
                const u = Math.random(), v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = planetRadius * Math.pow(Math.random(), 1/3);
                points.push({
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                });
            }

            const ringInner = 120, ringOuter = 280, ringTilt = 0.5;
            for (let i = 0; i < ringCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = ringInner + (ringOuter - ringInner) * Math.sqrt(Math.random());
                let x = Math.cos(angle) * r;
                let y = (Math.random() - 0.5) * 10;
                let z = Math.sin(angle) * r;
                const fY = y * Math.cos(ringTilt) - z * Math.sin(ringTilt);
                const fZ = y * Math.sin(ringTilt) + z * Math.cos(ringTilt);
                points.push({ x: x, y: fY, z: fZ });
            }
            return points;
        }

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.z = (Math.random() - 0.5) * 500;
                this.destX = 0; this.destY = 0; this.destZ = 0;
                this.vx = 0; this.vy = 0; this.vz = 0;
                this.accel = 0.02 + Math.random() * 0.04;
                this.friction = 0.88 + Math.random() * 0.04;
                this.size = Math.random() * 1.5 + 0.5;
            }

            update() {
                let jX = (Math.random() - 0.5) * JITTER_AMOUNT;
                let jY = (Math.random() - 0.5) * JITTER_AMOUNT;
                let jZ = (Math.random() - 0.5) * JITTER_AMOUNT;

                // Zoom applicato prima della rotazione
                let zX = this.destX * zoomScale;
                let zY = this.destY * zoomScale;
                let zZ = this.destZ * zoomScale;

                let rot = rotate3D(zX, zY, zZ, rotX, rotY);
                
                let tx = rot.x + canvas.width/2 + jX;
                let ty = rot.y + canvas.height/2 + jY;
                let tz = rot.z + jZ;

                this.vx += (tx - this.x) * this.accel;
                this.vy += (ty - this.y) * this.accel;
                this.vz += (tz - this.z) * this.accel;
                this.vx *= this.friction; this.vy *= this.friction; this.vz *= this.friction;
                this.x += this.vx; this.y += this.vy; this.z += this.vz;
            }

            draw() {
                const perspective = 800;
                const scale = perspective / (perspective + this.z);
                const dx = this.x * scale + (canvas.width / 2) * (1 - scale);
                const dy = this.y * scale + (canvas.height / 2) * (1 - scale);
                ctx.fillStyle = particleColor;
                ctx.globalAlpha = Math.min(1, Math.max(0.1, 0.7 * scale));
                ctx.beginPath();
                ctx.arc(dx, dy, Math.max(0.1, this.size * scale), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function setFormation(gesture) {
            currentGesture = gesture;
            let targetPoints = [];
            if (gesture === 'sphere') {
                targetPoints = getJupiterPoints(PARTICLE_COUNT);
                particleColor = '#ffcc00';
                isLocked = true;
            } else {
                particleColor = 'white';
                isLocked = false;
                zoomScale = 1.0;
                particles.forEach(p => {
                    p.destX = (Math.random()-0.5)*canvas.width;
                    p.destY = (Math.random()-0.5)*canvas.height;
                    p.destZ = (Math.random()-0.5)*500;
                });
                return;
            }
            particles.forEach((p, i) => {
                const t = targetPoints[i % targetPoints.length];
                p.destX = t.x; p.destY = t.y; p.destZ = t.z;
            });
        }

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            document.getElementById("status").innerText = "Sistemi Pronti.";
            startBtn.style.display = "inline-block";
        }

        startBtn.onclick = () => {
            ui.style.opacity = "0";
            setTimeout(() => ui.style.display = "none", 1000);
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.onloadeddata = () => requestAnimationFrame(loop);
            });
        };

        function loop() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const results = handLandmarker.detectForVideo(video, performance.now());
            if (results.landmarks && results.landmarks.length > 0) {
                const pts = results.landmarks[0];
                const d = (p1, p2) => Math.hypot(pts[p1].x - pts[p2].x, pts[p1].y - pts[p2].y);

                const isReset = pts[8].y < pts[6].y && pts[12].y > pts[10].y && pts[16].y > pts[14].y;

                if (isReset) {
                    if (isLocked) setFormation('none');
                    rotX = 0; rotY = 0;
                } else if (isLocked) {
                    // ROTAZIONE
                    rotY = (pts[8].x - 0.5) * Math.PI * 3;
                    rotX = (pts[8].y - 0.5) * Math.PI * 3;

                    // ZOOM
                    const isOpen = d(8, 0) > 0.45 && d(12, 0) > 0.45;
                    const isClick = d(8, 4) < 0.06;

                    if (isClick) {
                        zoomScale = Math.min(zoomScale + 0.02, 3.0);
                        label.innerText = "ZOOM IN +";
                    } else if (isOpen) {
                        zoomScale = Math.max(zoomScale - 0.02, 0.3);
                        label.innerText = "ZOOM OUT -";
                    } else {
                        label.innerText = "RUOTA CON L'INDICE | RESET CON â†‘";
                    }
                } else {
                    const isSphere = d(8, 0) < 0.25 && d(12, 0) < 0.35;
                    if (isSphere) setFormation('sphere');
                    label.innerText = "CHIUDI IL PUGNO PER GENERARE GIOVE";
                }
            }

            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(loop);
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(new Particle());
        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();
        initAI();
    </script>
</body>
</html>